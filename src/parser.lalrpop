use crate::{
    ast::{
        BinOpKind, Constant, ExprKind, FunctionDefinition, Statement,
        TypeSpecifier,
    },
    lexer::Token,
};

grammar<'a>;

pub FunctionDefinition: FunctionDefinition =
    <return_type:TypeSpecifier> <name:Identifier> LeftParen RightParen <body:CompoundStatement> => FunctionDefinition {<>};

TypeSpecifier: TypeSpecifier = {
    Int => TypeSpecifier::Int,
}

Statement = {
    ExpressionStatement,
    CompoundStatement => Statement::Compound(<>),
    JumpStatement,
}

ExpressionStatement: Statement =
    <AdditiveExpression> Semi => Statement::Expr(<>);

CompoundStatement = LeftBrace <StatementList> RightBrace;

StatementList: Vec<Statement> = {
    <Statement> => vec![<>],
    <mut sl:StatementList> <s:Statement> => {
        sl.push(s);
        sl
    },
};

JumpStatement: Statement =
    Return <AdditiveExpression?> Semi => Statement::Return(<>);

AdditiveExpression = {
    PrimaryExpression,
    <a:AdditiveExpression> Plus <b:PrimaryExpression> => ExprKind::Binary(BinOpKind::Add, Box::new(a), Box::new(b)),
    <a:AdditiveExpression> Minus <b:PrimaryExpression> => ExprKind::Binary(BinOpKind::Sub, Box::new(a), Box::new(b)),
};

PrimaryExpression: ExprKind = {
    Identifier => ExprKind::Identifier(<>),
    Constant => ExprKind::Constant(<>),
};

Constant: Constant = {
    Integer => Constant::Integer(<>),
};

extern {
    type Location = usize;
    type Error = anyhow::Error;

    enum Token {
        // Keywords
        Int => Token::Int,
        Return => Token::Return,

        // Operators
        Minus => Token::Minus,
        Plus => Token::Plus,
        
        // Punctuators
        Semi => Token::Semi,
        LeftParen => Token::LeftParen,
        RightParen => Token::RightParen,
        LeftBrace => Token::LeftBrace,
        RightBrace => Token::RightBrace,
        Comma => Token::Comma,

        // Literals
        Integer => Token::Integer(<i64>),

        Identifier => Token::Identifier(<String>),
    }
}